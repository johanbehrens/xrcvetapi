var unorm = require('unorm');
var combining = /[\u0300-\u036F]/g;

var writeFile = require('write-file-queue')({
	retries: 1000, // number of write attempts before failing
	waitTime: 200 // number of milliseconds to wait between write attempts
	//, debug : console.error 			// optionally pass a function to do dump debug information to
});

var net = require("net");
var config = undefined;
var printerConfig;
var buffer = null;

module.exports = {
	config: config = require('./config'),
	init: function(initConfig) {

		config = this.config;

		if (!initConfig.width) initConfig.width = 48;
		if (!initConfig.characterSet) initConfig.characterSet = "SPAIN2";

		printerConfig = initConfig;
	},

	execute: function(cb) {
		if (printerConfig.ip) {
			var printer = net.connect({
				host: printerConfig.ip,
				port: printerConfig.port
			});
			printer.write(buffer);
			printer.end();

		} else {
			writeFile(printerConfig.interface, buffer, function(err) {
				if (err) {
					if ("function" == typeof cb) {
						cb("Print failed: " + err);
					} else {
						console.error("Print failed", err);
					}
				} else {
					buffer = null;
					if ("function" == typeof cb) {
						cb(null);
					} else {
						console.log("Print done");
					}
				}
			});
		}
	},

	cut: function() {
		append(config.CTL_VT);
		append(config.CTL_VT);
		append(config.PAPER_FULL_CUT);
		append(config.HW_INIT);
	},

	getWidth: function() {
		return parseInt(printerConfig.width);
	},

	getText: function() {
		return buffer.toString();
	},

	getBuffer: function() {
		return buffer;
	},

	clear: function() {
		buffer = null;
	},

	add: function(buffer) {
		append(buffer);
	},

	print: function(text) {
		append(text.toString());
	},

	println: function(text) {
		append(text.toString());
		append("\n");
	},

	printVerticalTab: function() {
		append(config.CTL_VT);
	},

	bold: function(enabled) {
		if (enabled) append(config.TXT_BOLD_ON);
		else append(config.TXT_BOLD_OFF);
	},

	underline: function(enabled) {
		if (enabled) append(config.TXT_UNDERL_ON);
		else append(config.TXT_UNDERL_OFF);
	},

	underlineThick: function(enabled) {
		if (enabled) append(config.TXT_UNDERL2_ON);
		else append(config.TXT_UNDERL_OFF);
	},

	openCashDrawer: function() {
		append(config.CD_KICK_2);
		append(config.CD_KICK_5);
	},

	alignCenter: function() {
		append(config.TXT_ALIGN_CT);
	},

	alignLeft: function() {
		append(config.TXT_ALIGN_LT);
	},

	alignRight: function() {
		append(config.TXT_ALIGN_RT);
	},

	setTypeFontA: function() {
		append(config.TXT_FONT_A);
	},

	setTypeFontB: function() {
		append(config.TXT_FONT_B);
	},

	setTextNormal: function() {
		append(config.TXT_NORMAL);
	},

	setTextDoubleHeight: function() {
		append(config.TXT_2HEIGHT);
	},

	setTextDoubleWidth: function() {
		append(config.TXT_2WIDTH);
	},

	setTextQuadArea: function() {
		append(config.TXT_4SQUARE);
	},

	newLine: function(n) {
		for (var i = 0; i < (n || 1); i++)
			append("\n");
	},

	drawLine: function() {
		// module.exports.newLine();
		for (var i = 0; i < printerConfig.width; i++) {
			append(new Buffer("-"));
		}
		module.exports.newLine();
	},

	leftRight: function(left, right) {
		append(left.toString());
		var width = printerConfig.width - left.toString().length - right.toString().length;
		for (var i = 0; i < width; i++) {
			append(new Buffer(" "));
		}
		append(right.toString());
		module.exports.newLine();
	},

	table: function(data) {
		var cellWidth = printerConfig.width / data.length;
		for (var i = 0; i < data.length; i++) {
			append(data[i].toString());
			var spaces = cellWidth - data[i].toString().length;
			for (var j = 0; j < spaces; j++) {
				append(new Buffer(" "));
			}
		}
		module.exports.newLine();
	},


	// Options: text, align, width, bold
	tableCustom: function(data) {
		var cellWidth = printerConfig.width / data.length;
		var secondLine = [];
		var secondLineEnabled = false;

		for (var i = 0; i < data.length; i++) {
			var tooLong = false;
			var obj = data[i];
			obj.text = obj.text.toString();

			if (obj.width) cellWidth = printerConfig.width * obj.width;
			if (obj.bold) module.exports.bold(true);

			// If text is too wide go to next line
			if (cellWidth < obj.text.length) {
				tooLong = true;
				obj.originalText = obj.text;
				obj.text = obj.text.substring(0, cellWidth);
			}

			if (obj.align == "CENTER") {
				var spaces = (cellWidth - obj.text.toString().length) / 2;
				for (var j = 0; j < spaces; j++) {
					append(new Buffer(" "));
				}
				if (obj.text != '') append(obj.text);
				for (var j = 0; j < spaces - 1; j++) {
					append(new Buffer(" "));
				}

			} else if (obj.align == "RIGHT") {
				var spaces = cellWidth - obj.text.toString().length;
				for (var j = 0; j < spaces; j++) {
					append(new Buffer(" "));
				}
				if (obj.text != '') append(obj.text);

			} else {
				if (obj.text != '') append(obj.text);
				var spaces = cellWidth - obj.text.toString().length;
				for (var j = 0; j < spaces; j++) {
					append(new Buffer(" "));
				}

			}

			if (obj.bold) module.exports.bold(false);


			if (tooLong) {
				secondLineEnabled = true;
				obj.text = obj.originalText.substring(cellWidth - 1);
				secondLine.push(obj);
			} else {
				obj.text = "";
				secondLine.push(obj);
			}
		}

		module.exports.newLine();

		// Print the second line
		if (secondLineEnabled) {
			module.exports.tableCustom(secondLine);
		}
	},

	isPrinterConnected: function(exists) {
		if (printerConfig.interface) {
			var fs = require('fs');
			fs.exists(printerConfig.interface, function(ex) {
				exists(ex);
			});
		}

	},


	printQR: function(str) {

		// ------------------------------ Epson QR ------------------------------

		// [Name] Select the QR code model
		// [Code] 1D 28 6B 04 00 31 41 n1 n2
		// n1
		// [49 x31, model 1]
		// [50 x32, model 2]
		// [51 x33, micro qr code]
		// n2 = 0
		// https://reference.epson-biz.com/modules/ref_escpos/index.php?content_id=140
		append(config.QRCODE_MODEL1);

		// [Name]: Set the size of module
		// 1D 28 6B 03 00 31 43 n
		// n depends on the printer
		// https://reference.epson-biz.com/modules/ref_escpos/index.php?content_id=141
		append(config.QRCODE_CELLSIZE_6);


		// [Name] Select the error correction level
		// 1D 28 6B 03 00 31 45 n
		// n
		// [48 x30 -> 7%]
		// [49 x31-> 15%]
		// [50 x32 -> 25%]
		// [51 x33 -> 30%]
		// https://reference.epson-biz.com/modules/ref_escpos/index.php?content_id=142
		append(config.QRCODE_CORRECTION_M);


		// [Name] Store the data in the symbol storage area
		// 1D 28  6B pL pH 31 50 30 d1...dk
		// https://reference.epson-biz.com/modules/ref_escpos/index.php?content_id=143
		var s = str.length + 3;
		var lsb = parseInt(s % 256);
		var msb = parseInt(s / 256);
		append(new Buffer([0x1d, 0x28, 0x6b, lsb, msb, 0x31, 0x50, 0x30]));
		append(new Buffer(str));


		// [Name] Print the symbol data in the symbol storage area
		// 1D 28 6B 03 00 31 51 m
		// https://reference.epson-biz.com/modules/ref_escpos/index.php?content_id=144
		append(config.QRCODE_PRINT);


	},


	printBarcode: function(data, options) {
		options = options || {};

		var pos = !options.pos || option.pos < 0 || options.pos > 2 ? 2 : options.pos; //text pos. 0-3. 0 - don`t display, 1 - on top, 2 - on bottom
		var width = options.size || 3; //barcode width. 2-3. default is 3
		var type = options.type || config.BARCODE_EAN13; //set barcode type

		append(new Buffer([29, 72, pos]));
		append(new Buffer([29, 119, width])); //barcode width. 2-3. default is 3
		append(new Buffer([29, 107, type]));
		append(data);

	},

	raw: function(text, cb) {
		if (printerConfig.ip) {
			var printer = net.connect({
				host: printerConfig.ip,
				port: printerConfig.port
			});
			printer.write(text);
			printer.end();

		} else {
			writeFile(printerConfig.interface, text, function(err) {
				if (err) {
					if ('function' == typeof cb) {
						cb("Print failed: " + err);
					} else {
						console.error("Print failed", err);
					}
				} else {
					if ('function' == typeof cb) {
						cb("Print failed: " + err);
					} else {
						console.log("Print done");
					}
				}
			});
		}
	}
};


var setInternationalCharacterSet = function(charSet) {

	// ------------------------------ Epson Character set ------------------------------
	if (charSet == "USA") return config.CHARCODE_USA;
	if (charSet == "FRANCE") return config.CHARCODE_FRANCE;
	if (charSet == "GERMANY") return config.CHARCODE_GERMANY;
	if (charSet == "UK") return config.CHARCODE_UK;
	if (charSet == "DENMARK1") return config.CHARCODE_DENMARK1;
	if (charSet == "SWEDEN") return config.CHARCODE_SWEDEN;
	if (charSet == "ITALY") return config.CHARCODE_ITALY;
	if (charSet == "SPAIN1") return config.CHARCODE_SPAIN1;
	if (charSet == "JAPAN") return config.CHARCODE_JAPAN;
	if (charSet == "NORWAY") return config.CHARCODE_NORWAY;
	if (charSet == "DENMARK2") return config.CHARCODE_DENMARK2;
	if (charSet == "SPAIN2") return config.CHARCODE_SPAIN2;
	if (charSet == "LATINA") return config.CHARCODE_LATINA;
	if (charSet == "KOREA") return config.CHARCODE_KOREA;
	if (charSet == "SLOVENIA") return config.CHARCODE_SLOVENIA;
	if (charSet == "CHINA") return config.CHARCODE_CHINA;
	if (charSet == "VIETNAM") return config.CHARCODE_VIETNAM;
	if (charSet == "ARABIA") return config.CHARCODE_ARABIA;
	return null;

};


var append = function(buff) {
	if (typeof buff == "string") {
		buff = unorm.nfkd(buff).replace(combining, '');

		var endBuff = null;
		for (var i = 0; i < buff.length; i++) {
			var value = buff[i];
			var tempBuff = new Buffer(value);
			// Replace special characters
			for (var key in config.specialCharacters) {
				if (value == key) {
					tempBuff = new Buffer([config.specialCharacters[key]]);
					break;
				}
			}

			if (endBuff) endBuff = Buffer.concat([endBuff, tempBuff]);
			else endBuff = tempBuff;
		}

		buff = endBuff;
	}




	if (!buffer && printerConfig.characterSet) buffer = setInternationalCharacterSet(printerConfig.characterSet);
	if (buffer) {
		buffer = Buffer.concat([buffer, buff]);
	} else {
		buffer = buff;
	}
};


var fix = function(str) {
	return unorm.nfkd(str).replace(combining, '');
};